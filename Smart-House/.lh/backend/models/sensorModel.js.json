{
    "sourceFile": "backend/models/sensorModel.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1746469322245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746470264153,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,303 @@\n+const db = require('../config/db');\r\n+\r\n+class SensorModel {\r\n+  static async getAllSensors() {\r\n+    try {\r\n+      const query = `\r\n+        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n+        FROM sensor s\r\n+        ORDER BY s.sensor_type\r\n+      `;\r\n+      \r\n+      const result = await db.query(query);\r\n+      console.log(`Found ${result.rows.length} sensors`);\r\n+      return result.rows;\r\n+    } catch (error) {\r\n+      console.error(`Error getting all sensors: ${error.message}`);\r\n+      throw new Error(`Error getting all sensors: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async getSensorById(id) {\r\n+    try {\r\n+      const query = `\r\n+        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n+        FROM sensor s\r\n+        WHERE s.sensor_id = $1\r\n+      `;\r\n+      \r\n+      const result = await db.query(query, [id]);\r\n+      \r\n+      if (result.rows.length === 0) {\r\n+        return null;\r\n+      }\r\n+      \r\n+      return result.rows[0];\r\n+    } catch (error) {\r\n+      throw new Error(`Error getting sensor by ID: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async getSensorByType(type) {\r\n+    try {\r\n+      const query = `\r\n+        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n+        FROM sensor s\r\n+        WHERE LOWER(s.sensor_type) = LOWER($1)\r\n+        LIMIT 1\r\n+      `;\r\n+      \r\n+      const result = await db.query(query, [type]);\r\n+      \r\n+      if (result.rows.length === 0) {\r\n+        console.log(`No sensor found with type: ${type}`);\r\n+        return null;\r\n+      }\r\n+      \r\n+      return result.rows[0];\r\n+    } catch (error) {\r\n+      console.error(`Error getting sensor by type: ${error.message}`);\r\n+      throw new Error(`Error getting sensor by type: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async createSensor(sensorData) {\r\n+    try {\r\n+      const query = `\r\n+        INSERT INTO sensor (sensor_type, model, unit, description)\r\n+        VALUES ($1, $2, $3, $4)\r\n+        RETURNING *\r\n+      `;\r\n+      \r\n+      const values = [\r\n+        sensorData.type,\r\n+        sensorData.model,\r\n+        sensorData.unit,\r\n+        sensorData.description\r\n+      ];\r\n+      \r\n+      const result = await db.query(query, values);\r\n+      return result.rows[0];\r\n+    } catch (error) {\r\n+      throw new Error(`Error creating sensor: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async updateSensor(id, sensorData) {\r\n+    try {\r\n+      // Build the SET clause dynamically\r\n+      const setClause = Object.keys(sensorData)\r\n+        .map((key, index) => {\r\n+          // Map the JS property names to DB column names\r\n+          const columnMapping = {\r\n+            type: 'sensor_type',\r\n+            model: 'model',\r\n+            unit: 'unit',\r\n+            description: 'description'\r\n+          };\r\n+          \r\n+          return `${columnMapping[key]} = $${index + 1}`;\r\n+        })\r\n+        .join(', ');\r\n+      \r\n+      // Build the query\r\n+      const query = `\r\n+        UPDATE sensor\r\n+        SET ${setClause}\r\n+        WHERE sensor_id = $${Object.keys(sensorData).length + 1}\r\n+        RETURNING *\r\n+      `;\r\n+      \r\n+      // Build the values array\r\n+      const values = [...Object.values(sensorData), id];\r\n+      \r\n+      const result = await db.query(query, values);\r\n+      \r\n+      if (result.rows.length === 0) {\r\n+        return null;\r\n+      }\r\n+      \r\n+      return result.rows[0];\r\n+    } catch (error) {\r\n+      throw new Error(`Error updating sensor: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async deleteSensor(id) {\r\n+    try {\r\n+      const query = 'DELETE FROM sensor WHERE sensor_id = $1 RETURNING sensor_id';\r\n+      const result = await db.query(query, [id]);\r\n+      \r\n+      if (result.rows.length === 0) {\r\n+        return false;\r\n+      }\r\n+      \r\n+      return true;\r\n+    } catch (error) {\r\n+      throw new Error(`Error deleting sensor: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async getSensorData(sensorId, limit = 100) {\r\n+    try {\r\n+      const query = `\r\n+        SELECT sd.data_id, sd.sensor_id, sd.svalue, sd.recorded_time\r\n+        FROM sensor_data sd\r\n+        WHERE sd.sensor_id = $1\r\n+        ORDER BY sd.recorded_time DESC\r\n+        LIMIT $2\r\n+      `;\r\n+      \r\n+      const result = await db.query(query, [sensorId, limit]);\r\n+      return result.rows;\r\n+    } catch (error) {\r\n+      console.error(`Error getting sensor data: ${error.message}`);\r\n+      throw new Error(`Error getting sensor data: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async getLatestSensorData(sensorId) {\r\n+    try {\r\n+      console.log(`Getting latest data for sensor ID: ${sensorId}`);\r\n+      \r\n+      // Ensure that numerical values are properly formatted\r\n+      const query = `\r\n+        SELECT \r\n+          sd.data_id, \r\n+          sd.sensor_id, \r\n+          CAST(sd.svalue AS FLOAT) AS svalue,\r\n+          sd.recorded_time\r\n+        FROM sensor_data sd\r\n+        WHERE sd.sensor_id = $1\r\n+        ORDER BY sd.recorded_time DESC\r\n+        LIMIT 1\r\n+      `;\r\n+      \r\n+      const result = await db.query(query, [sensorId]);\r\n+      \r\n+      if (result.rows.length === 0) {\r\n+        console.log(`No data found for sensor ID: ${sensorId}`);\r\n+        return null;\r\n+      }\r\n+      \r\n+      const data = result.rows[0];\r\n+      console.log(`Latest data for sensor ${sensorId}: ${data.svalue} (${typeof data.svalue})`);\r\n+      \r\n+      return data;\r\n+    } catch (error) {\r\n+      console.error(`Error getting latest sensor data: ${error.message}`);\r\n+      throw new Error(`Error getting latest sensor data: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  static async insertSensorData(sensorId, value, timestamp = null) {\r\n+    try {\r\n+      // Ensure value is a number\r\n+      const numericValue = parseFloat(value);\r\n+      \r\n+      if (isNaN(numericValue)) {\r\n+        throw new Error(`Invalid sensor value: ${value}`);\r\n+      }\r\n+      \r\n+      let query;\r\n+      let values;\r\n+      \r\n+      if (timestamp) {\r\n+        query = `\r\n+          INSERT INTO sensor_data (sensor_id, svalue, recorded_time)\r\n+          VALUES ($1, $2, $3)\r\n+          RETURNING *\r\n+        `;\r\n+        values = [sensorId, numericValue, timestamp];\r\n+      } else {\r\n+        query = `\r\n+          INSERT INTO sensor_data (sensor_id, svalue)\r\n+          VALUES ($1, $2)\r\n+          RETURNING *\r\n+        `;\r\n+        values = [sensorId, numericValue];\r\n+      }\r\n+      \r\n+      console.log(`Inserting sensor data: sensorId=${sensorId}, value=${numericValue}`);\r\n+      const result = await db.query(query, values);\r\n+      console.log(`Sensor data inserted successfully:`, result.rows[0]);\r\n+      \r\n+      // Kích hoạt kiểm tra cảnh báo ngay lập tức (sử dụng setTimeout để tránh circular dependency)\r\n+      setTimeout(async () => {\r\n+        try {\r\n+          console.log(`Đang kích hoạt kiểm tra cảnh báo cho dữ liệu mới của cảm biến ${sensorId}...`);\r\n+          const alertMonitorService = require('../services/alertMonitorService');\r\n+          await alertMonitorService.checkThresholds();\r\n+          console.log(`Kiểm tra cảnh báo hoàn tất cho dữ liệu mới`);\r\n+        } catch (alertError) {\r\n+          console.error(`Lỗi kiểm tra cảnh báo cho dữ liệu mới: ${alertError.message}`);\r\n+        }\r\n+      }, 500); // Đợi 0.5 giây để đảm bảo dữ liệu đã được lưu đầy đủ\r\n+      \r\n+      return result.rows[0];\r\n+    } catch (error) {\r\n+      console.error(`Error inserting sensor data: ${error.message}`);\r\n+      throw new Error(`Error inserting sensor data: ${error.message}`);\r\n+    }\r\n+  }\r\n+  \r\n+  // Method to check if sensor value exceeds thresholds\r\n+  static async checkSensorThresholds(sensorId, value) {\r\n+    try {\r\n+      console.log(`Checking if sensor ${sensorId} value ${value} exceeds thresholds`);\r\n+      \r\n+      // Get sensor type\r\n+      const sensor = await this.getSensorById(sensorId);\r\n+      if (!sensor) {\r\n+        throw new Error(`Sensor with ID ${sensorId} not found`);\r\n+      }\r\n+      \r\n+      // Get alert configurations for this sensor type\r\n+      const query = `\r\n+        SELECT config_id, user_id, sensor_type, min_value, max_value\r\n+        FROM alert_config\r\n+        WHERE is_active = true AND LOWER(sensor_type) = LOWER($1)\r\n+      `;\r\n+      \r\n+      const result = await db.query(query, [sensor.sensor_type]);\r\n+      const configs = result.rows;\r\n+      \r\n+      console.log(`Found ${configs.length} alert configurations for sensor type ${sensor.sensor_type}`);\r\n+      \r\n+      const thresholdExceeded = {\r\n+        isExceeded: false,\r\n+        threshold: null,\r\n+        type: null, // 'high' or 'low'\r\n+        config: null\r\n+      };\r\n+      \r\n+      // Check each configuration\r\n+      for (const config of configs) {\r\n+        console.log(`Checking config min_value=${config.min_value}, max_value=${config.max_value}`);\r\n+        \r\n+        if (value < config.min_value) {\r\n+          console.log(`Low threshold exceeded: ${value} < ${config.min_value}`);\r\n+          thresholdExceeded.isExceeded = true;\r\n+          thresholdExceeded.threshold = config.min_value;\r\n+          thresholdExceeded.type = 'low';\r\n+          thresholdExceeded.config = config;\r\n+          break;\r\n+        } else if (value > config.max_value) {\r\n+          console.log(`High threshold exceeded: ${value} > ${config.max_value}`);\r\n+          thresholdExceeded.isExceeded = true;\r\n+          thresholdExceeded.threshold = config.max_value;\r\n+          thresholdExceeded.type = 'high';\r\n+          thresholdExceeded.config = config;\r\n+          break;\r\n+        }\r\n+      }\r\n+      \r\n+      return thresholdExceeded;\r\n+    } catch (error) {\r\n+      console.error(`Error checking sensor thresholds: ${error.message}`);\r\n+      throw new Error(`Error checking sensor thresholds: ${error.message}`);\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+module.exports = SensorModel;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746471060261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -221,327 +221,34 @@\n       console.log(`Inserting sensor data: sensorId=${sensorId}, value=${numericValue}`);\r\n       const result = await db.query(query, values);\r\n       console.log(`Sensor data inserted successfully:`, result.rows[0]);\r\n       \r\n-      // Kích hoạt kiểm tra cảnh báo ngay lập tức (sử dụng setTimeout để tránh circular dependency)\r\n+      // Lấy thông tin về cảm biến để ghi log\r\n+      const sensorQuery = `SELECT * FROM sensor WHERE sensor_id = $1`;\r\n+      const sensorResult = await db.query(sensorQuery, [sensorId]);\r\n+      const sensor = sensorResult.rows[0];\r\n+      const sensorType = sensor ? sensor.sensor_type : 'unknown';\r\n+      \r\n+      console.log(`Sensor type: ${sensorType}, New value: ${numericValue}`);\r\n+      \r\n+      // Kích hoạt kiểm tra cảnh báo sau khi thêm dữ liệu\r\n+      // Sử dụng setTimeout để tránh circular dependency\r\n       setTimeout(async () => {\r\n         try {\r\n-          console.log(`Đang kích hoạt kiểm tra cảnh báo cho dữ liệu mới của cảm biến ${sensorId}...`);\r\n+          console.log(`[${new Date().toLocaleTimeString()}] Kích hoạt kiểm tra cảnh báo cho dữ liệu mới ${sensorType}=${numericValue}`);\r\n+          \r\n+          // Dynamic import để giải quyết vấn đề circular dependency\r\n           const alertMonitorService = require('../services/alertMonitorService');\r\n+          \r\n+          // Chạy kiểm tra ngưỡng cảnh báo ngay lập tức\r\n           await alertMonitorService.checkThresholds();\r\n-          console.log(`Kiểm tra cảnh báo hoàn tất cho dữ liệu mới`);\r\n-        } catch (alertError) {\r\n-          console.error(`Lỗi kiểm tra cảnh báo cho dữ liệu mới: ${alertError.message}`);\r\n-        }\r\n-      }, 500); // Đợi 0.5 giây để đảm bảo dữ liệu đã được lưu đầy đủ\r\n-      \r\n-      return result.rows[0];\r\n-    } catch (error) {\r\n-      console.error(`Error inserting sensor data: ${error.message}`);\r\n-      throw new Error(`Error inserting sensor data: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  // Method to check if sensor value exceeds thresholds\r\n-  static async checkSensorThresholds(sensorId, value) {\r\n-    try {\r\n-      console.log(`Checking if sensor ${sensorId} value ${value} exceeds thresholds`);\r\n-      \r\n-      // Get sensor type\r\n-      const sensor = await this.getSensorById(sensorId);\r\n-      if (!sensor) {\r\n-        throw new Error(`Sensor with ID ${sensorId} not found`);\r\n-      }\r\n-      \r\n-      // Get alert configurations for this sensor type\r\n-      const query = `\r\n-        SELECT config_id, user_id, sensor_type, min_value, max_value\r\n-        FROM alert_config\r\n-        WHERE is_active = true AND LOWER(sensor_type) = LOWER($1)\r\n-      `;\r\n-      \r\n-      const result = await db.query(query, [sensor.sensor_type]);\r\n-      const configs = result.rows;\r\n-      \r\n-      console.log(`Found ${configs.length} alert configurations for sensor type ${sensor.sensor_type}`);\r\n-      \r\n-      const thresholdExceeded = {\r\n-        isExceeded: false,\r\n-        threshold: null,\r\n-        type: null, // 'high' or 'low'\r\n-        config: null\r\n-      };\r\n-      \r\n-      // Check each configuration\r\n-      for (const config of configs) {\r\n-        console.log(`Checking config min_value=${config.min_value}, max_value=${config.max_value}`);\r\n-        \r\n-        if (value < config.min_value) {\r\n-          console.log(`Low threshold exceeded: ${value} < ${config.min_value}`);\r\n-          thresholdExceeded.isExceeded = true;\r\n-          thresholdExceeded.threshold = config.min_value;\r\n-          thresholdExceeded.type = 'low';\r\n-          thresholdExceeded.config = config;\r\n-          break;\r\n-        } else if (value > config.max_value) {\r\n-          console.log(`High threshold exceeded: ${value} > ${config.max_value}`);\r\n-          thresholdExceeded.isExceeded = true;\r\n-          thresholdExceeded.threshold = config.max_value;\r\n-          thresholdExceeded.type = 'high';\r\n-          thresholdExceeded.config = config;\r\n-          break;\r\n-        }\r\n-      }\r\n-      \r\n-      return thresholdExceeded;\r\n-    } catch (error) {\r\n-      console.error(`Error checking sensor thresholds: ${error.message}`);\r\n-      throw new Error(`Error checking sensor thresholds: ${error.message}`);\r\n-    }\r\n-  }\r\n-}\r\n-\r\n-module.exports = SensorModel;\n-const db = require('../config/db');\r\n-\r\n-class SensorModel {\r\n-  static async getAllSensors() {\r\n-    try {\r\n-      const query = `\r\n-        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n-        FROM sensor s\r\n-        ORDER BY s.sensor_type\r\n-      `;\r\n-      \r\n-      const result = await db.query(query);\r\n-      console.log(`Found ${result.rows.length} sensors`);\r\n-      return result.rows;\r\n-    } catch (error) {\r\n-      console.error(`Error getting all sensors: ${error.message}`);\r\n-      throw new Error(`Error getting all sensors: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async getSensorById(id) {\r\n-    try {\r\n-      const query = `\r\n-        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n-        FROM sensor s\r\n-        WHERE s.sensor_id = $1\r\n-      `;\r\n-      \r\n-      const result = await db.query(query, [id]);\r\n-      \r\n-      if (result.rows.length === 0) {\r\n-        return null;\r\n-      }\r\n-      \r\n-      return result.rows[0];\r\n-    } catch (error) {\r\n-      throw new Error(`Error getting sensor by ID: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async getSensorByType(type) {\r\n-    try {\r\n-      const query = `\r\n-        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n-        FROM sensor s\r\n-        WHERE LOWER(s.sensor_type) = LOWER($1)\r\n-        LIMIT 1\r\n-      `;\r\n-      \r\n-      const result = await db.query(query, [type]);\r\n-      \r\n-      if (result.rows.length === 0) {\r\n-        console.log(`No sensor found with type: ${type}`);\r\n-        return null;\r\n-      }\r\n-      \r\n-      return result.rows[0];\r\n-    } catch (error) {\r\n-      console.error(`Error getting sensor by type: ${error.message}`);\r\n-      throw new Error(`Error getting sensor by type: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async createSensor(sensorData) {\r\n-    try {\r\n-      const query = `\r\n-        INSERT INTO sensor (sensor_type, model, unit, description)\r\n-        VALUES ($1, $2, $3, $4)\r\n-        RETURNING *\r\n-      `;\r\n-      \r\n-      const values = [\r\n-        sensorData.type,\r\n-        sensorData.model,\r\n-        sensorData.unit,\r\n-        sensorData.description\r\n-      ];\r\n-      \r\n-      const result = await db.query(query, values);\r\n-      return result.rows[0];\r\n-    } catch (error) {\r\n-      throw new Error(`Error creating sensor: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async updateSensor(id, sensorData) {\r\n-    try {\r\n-      // Build the SET clause dynamically\r\n-      const setClause = Object.keys(sensorData)\r\n-        .map((key, index) => {\r\n-          // Map the JS property names to DB column names\r\n-          const columnMapping = {\r\n-            type: 'sensor_type',\r\n-            model: 'model',\r\n-            unit: 'unit',\r\n-            description: 'description'\r\n-          };\r\n           \r\n-          return `${columnMapping[key]} = $${index + 1}`;\r\n-        })\r\n-        .join(', ');\r\n-      \r\n-      // Build the query\r\n-      const query = `\r\n-        UPDATE sensor\r\n-        SET ${setClause}\r\n-        WHERE sensor_id = $${Object.keys(sensorData).length + 1}\r\n-        RETURNING *\r\n-      `;\r\n-      \r\n-      // Build the values array\r\n-      const values = [...Object.values(sensorData), id];\r\n-      \r\n-      const result = await db.query(query, values);\r\n-      \r\n-      if (result.rows.length === 0) {\r\n-        return null;\r\n-      }\r\n-      \r\n-      return result.rows[0];\r\n-    } catch (error) {\r\n-      throw new Error(`Error updating sensor: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async deleteSensor(id) {\r\n-    try {\r\n-      const query = 'DELETE FROM sensor WHERE sensor_id = $1 RETURNING sensor_id';\r\n-      const result = await db.query(query, [id]);\r\n-      \r\n-      if (result.rows.length === 0) {\r\n-        return false;\r\n-      }\r\n-      \r\n-      return true;\r\n-    } catch (error) {\r\n-      throw new Error(`Error deleting sensor: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async getSensorData(sensorId, limit = 100) {\r\n-    try {\r\n-      const query = `\r\n-        SELECT sd.data_id, sd.sensor_id, sd.svalue, sd.recorded_time\r\n-        FROM sensor_data sd\r\n-        WHERE sd.sensor_id = $1\r\n-        ORDER BY sd.recorded_time DESC\r\n-        LIMIT $2\r\n-      `;\r\n-      \r\n-      const result = await db.query(query, [sensorId, limit]);\r\n-      return result.rows;\r\n-    } catch (error) {\r\n-      console.error(`Error getting sensor data: ${error.message}`);\r\n-      throw new Error(`Error getting sensor data: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async getLatestSensorData(sensorId) {\r\n-    try {\r\n-      console.log(`Getting latest data for sensor ID: ${sensorId}`);\r\n-      \r\n-      // Ensure that numerical values are properly formatted\r\n-      const query = `\r\n-        SELECT \r\n-          sd.data_id, \r\n-          sd.sensor_id, \r\n-          CAST(sd.svalue AS FLOAT) AS svalue,\r\n-          sd.recorded_time\r\n-        FROM sensor_data sd\r\n-        WHERE sd.sensor_id = $1\r\n-        ORDER BY sd.recorded_time DESC\r\n-        LIMIT 1\r\n-      `;\r\n-      \r\n-      const result = await db.query(query, [sensorId]);\r\n-      \r\n-      if (result.rows.length === 0) {\r\n-        console.log(`No data found for sensor ID: ${sensorId}`);\r\n-        return null;\r\n-      }\r\n-      \r\n-      const data = result.rows[0];\r\n-      console.log(`Latest data for sensor ${sensorId}: ${data.svalue} (${typeof data.svalue})`);\r\n-      \r\n-      return data;\r\n-    } catch (error) {\r\n-      console.error(`Error getting latest sensor data: ${error.message}`);\r\n-      throw new Error(`Error getting latest sensor data: ${error.message}`);\r\n-    }\r\n-  }\r\n-  \r\n-  static async insertSensorData(sensorId, value, timestamp = null) {\r\n-    try {\r\n-      let query;\r\n-      let values;\r\n-      \r\n-      // Ensure value is a number\r\n-      const numericValue = parseFloat(value);\r\n-      \r\n-      if (isNaN(numericValue)) {\r\n-        throw new Error(`Invalid sensor value: ${value}`);\r\n-      }\r\n-      \r\n-      if (timestamp) {\r\n-        query = `\r\n-          INSERT INTO sensor_data (sensor_id, svalue, recorded_time)\r\n-          VALUES ($1, $2, $3)\r\n-          RETURNING *\r\n-        `;\r\n-        values = [sensorId, numericValue, timestamp];\r\n-      } else {\r\n-        query = `\r\n-          INSERT INTO sensor_data (sensor_id, svalue)\r\n-          VALUES ($1, $2)\r\n-          RETURNING *\r\n-        `;\r\n-        values = [sensorId, numericValue];\r\n-      }\r\n-      \r\n-      console.log(`Inserting sensor data: sensorId=${sensorId}, value=${numericValue}`);\r\n-      const result = await db.query(query, values);\r\n-      console.log(`Sensor data inserted successfully:`, result.rows[0]);\r\n-      \r\n-      // Không cần kiểm tra ngưỡng ở đây nữa vì database trigger sẽ tự động làm\r\n-      \r\n-      return result.rows[0];\r\n-      console.log(`Đã chèn dữ liệu cảm biến mới: sensorId=${sensorId}, value=${numericValue}`);\r\n-    \r\n-      // Kích hoạt kiểm tra cảnh báo ngay lập tức\r\n-      const alertMonitorService = require('../services/alertMonitorService');\r\n-      setTimeout(async () => {\r\n-        try {\r\n-          console.log(`Đang kiểm tra cảnh báo cho dữ liệu mới của cảm biến ${sensorId}...`);\r\n-          await alertMonitorService.checkThresholds();\r\n-          console.log(`Kiểm tra cảnh báo hoàn tất cho dữ liệu mới`);\r\n+          console.log(`[${new Date().toLocaleTimeString()}] Hoàn tất kiểm tra cảnh báo cho dữ liệu mới`);\r\n         } catch (err) {\r\n-          console.error(`Lỗi kiểm tra cảnh báo: ${err.message}`);\r\n+          console.error(`Lỗi khi kiểm tra cảnh báo cho dữ liệu mới: ${err.message}`);\r\n+          console.error(err.stack);\r\n         }\r\n-      }, 500); // Chờ 0.5 giây để dữ liệu được lưu hoàn tất\r\n+      }, 500); // Đợi 0.5 giây để đảm bảo dữ liệu đã được lưu hoàn toàn\r\n       \r\n       return result.rows[0];\r\n     } catch (error) {\r\n       console.error(`Error inserting sensor data: ${error.message}`);\r\n"
                },
                {
                    "date": 1746471346450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -221,34 +221,19 @@\n       console.log(`Inserting sensor data: sensorId=${sensorId}, value=${numericValue}`);\r\n       const result = await db.query(query, values);\r\n       console.log(`Sensor data inserted successfully:`, result.rows[0]);\r\n       \r\n-      // Lấy thông tin về cảm biến để ghi log\r\n-      const sensorQuery = `SELECT * FROM sensor WHERE sensor_id = $1`;\r\n-      const sensorResult = await db.query(sensorQuery, [sensorId]);\r\n-      const sensor = sensorResult.rows[0];\r\n-      const sensorType = sensor ? sensor.sensor_type : 'unknown';\r\n-      \r\n-      console.log(`Sensor type: ${sensorType}, New value: ${numericValue}`);\r\n-      \r\n-      // Kích hoạt kiểm tra cảnh báo sau khi thêm dữ liệu\r\n-      // Sử dụng setTimeout để tránh circular dependency\r\n+      // Kích hoạt kiểm tra cảnh báo ngay lập tức (sử dụng setTimeout để tránh circular dependency)\r\n       setTimeout(async () => {\r\n         try {\r\n-          console.log(`[${new Date().toLocaleTimeString()}] Kích hoạt kiểm tra cảnh báo cho dữ liệu mới ${sensorType}=${numericValue}`);\r\n-          \r\n-          // Dynamic import để giải quyết vấn đề circular dependency\r\n+          console.log(`Đang kích hoạt kiểm tra cảnh báo cho dữ liệu mới của cảm biến ${sensorId}...`);\r\n           const alertMonitorService = require('../services/alertMonitorService');\r\n-          \r\n-          // Chạy kiểm tra ngưỡng cảnh báo ngay lập tức\r\n           await alertMonitorService.checkThresholds();\r\n-          \r\n-          console.log(`[${new Date().toLocaleTimeString()}] Hoàn tất kiểm tra cảnh báo cho dữ liệu mới`);\r\n-        } catch (err) {\r\n-          console.error(`Lỗi khi kiểm tra cảnh báo cho dữ liệu mới: ${err.message}`);\r\n-          console.error(err.stack);\r\n+          console.log(`Kiểm tra cảnh báo hoàn tất cho dữ liệu mới`);\r\n+        } catch (alertError) {\r\n+          console.error(`Lỗi kiểm tra cảnh báo cho dữ liệu mới: ${alertError.message}`);\r\n         }\r\n-      }, 500); // Đợi 0.5 giây để đảm bảo dữ liệu đã được lưu hoàn toàn\r\n+      }, 500); // Đợi 0.5 giây để đảm bảo dữ liệu đã được lưu đầy đủ\r\n       \r\n       return result.rows[0];\r\n     } catch (error) {\r\n       console.error(`Error inserting sensor data: ${error.message}`);\r\n"
                }
            ],
            "date": 1746469322245,
            "name": "Commit-0",
            "content": "const db = require('../config/db');\r\n\r\nclass SensorModel {\r\n  static async getAllSensors() {\r\n    try {\r\n      const query = `\r\n        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n        FROM sensor s\r\n        ORDER BY s.sensor_type\r\n      `;\r\n      \r\n      const result = await db.query(query);\r\n      console.log(`Found ${result.rows.length} sensors`);\r\n      return result.rows;\r\n    } catch (error) {\r\n      console.error(`Error getting all sensors: ${error.message}`);\r\n      throw new Error(`Error getting all sensors: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async getSensorById(id) {\r\n    try {\r\n      const query = `\r\n        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n        FROM sensor s\r\n        WHERE s.sensor_id = $1\r\n      `;\r\n      \r\n      const result = await db.query(query, [id]);\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      return result.rows[0];\r\n    } catch (error) {\r\n      throw new Error(`Error getting sensor by ID: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async getSensorByType(type) {\r\n    try {\r\n      const query = `\r\n        SELECT s.sensor_id, s.sensor_type, s.model, s.unit, s.description\r\n        FROM sensor s\r\n        WHERE LOWER(s.sensor_type) = LOWER($1)\r\n        LIMIT 1\r\n      `;\r\n      \r\n      const result = await db.query(query, [type]);\r\n      \r\n      if (result.rows.length === 0) {\r\n        console.log(`No sensor found with type: ${type}`);\r\n        return null;\r\n      }\r\n      \r\n      return result.rows[0];\r\n    } catch (error) {\r\n      console.error(`Error getting sensor by type: ${error.message}`);\r\n      throw new Error(`Error getting sensor by type: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async createSensor(sensorData) {\r\n    try {\r\n      const query = `\r\n        INSERT INTO sensor (sensor_type, model, unit, description)\r\n        VALUES ($1, $2, $3, $4)\r\n        RETURNING *\r\n      `;\r\n      \r\n      const values = [\r\n        sensorData.type,\r\n        sensorData.model,\r\n        sensorData.unit,\r\n        sensorData.description\r\n      ];\r\n      \r\n      const result = await db.query(query, values);\r\n      return result.rows[0];\r\n    } catch (error) {\r\n      throw new Error(`Error creating sensor: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async updateSensor(id, sensorData) {\r\n    try {\r\n      // Build the SET clause dynamically\r\n      const setClause = Object.keys(sensorData)\r\n        .map((key, index) => {\r\n          // Map the JS property names to DB column names\r\n          const columnMapping = {\r\n            type: 'sensor_type',\r\n            model: 'model',\r\n            unit: 'unit',\r\n            description: 'description'\r\n          };\r\n          \r\n          return `${columnMapping[key]} = $${index + 1}`;\r\n        })\r\n        .join(', ');\r\n      \r\n      // Build the query\r\n      const query = `\r\n        UPDATE sensor\r\n        SET ${setClause}\r\n        WHERE sensor_id = $${Object.keys(sensorData).length + 1}\r\n        RETURNING *\r\n      `;\r\n      \r\n      // Build the values array\r\n      const values = [...Object.values(sensorData), id];\r\n      \r\n      const result = await db.query(query, values);\r\n      \r\n      if (result.rows.length === 0) {\r\n        return null;\r\n      }\r\n      \r\n      return result.rows[0];\r\n    } catch (error) {\r\n      throw new Error(`Error updating sensor: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async deleteSensor(id) {\r\n    try {\r\n      const query = 'DELETE FROM sensor WHERE sensor_id = $1 RETURNING sensor_id';\r\n      const result = await db.query(query, [id]);\r\n      \r\n      if (result.rows.length === 0) {\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      throw new Error(`Error deleting sensor: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async getSensorData(sensorId, limit = 100) {\r\n    try {\r\n      const query = `\r\n        SELECT sd.data_id, sd.sensor_id, sd.svalue, sd.recorded_time\r\n        FROM sensor_data sd\r\n        WHERE sd.sensor_id = $1\r\n        ORDER BY sd.recorded_time DESC\r\n        LIMIT $2\r\n      `;\r\n      \r\n      const result = await db.query(query, [sensorId, limit]);\r\n      return result.rows;\r\n    } catch (error) {\r\n      console.error(`Error getting sensor data: ${error.message}`);\r\n      throw new Error(`Error getting sensor data: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async getLatestSensorData(sensorId) {\r\n    try {\r\n      console.log(`Getting latest data for sensor ID: ${sensorId}`);\r\n      \r\n      // Ensure that numerical values are properly formatted\r\n      const query = `\r\n        SELECT \r\n          sd.data_id, \r\n          sd.sensor_id, \r\n          CAST(sd.svalue AS FLOAT) AS svalue,\r\n          sd.recorded_time\r\n        FROM sensor_data sd\r\n        WHERE sd.sensor_id = $1\r\n        ORDER BY sd.recorded_time DESC\r\n        LIMIT 1\r\n      `;\r\n      \r\n      const result = await db.query(query, [sensorId]);\r\n      \r\n      if (result.rows.length === 0) {\r\n        console.log(`No data found for sensor ID: ${sensorId}`);\r\n        return null;\r\n      }\r\n      \r\n      const data = result.rows[0];\r\n      console.log(`Latest data for sensor ${sensorId}: ${data.svalue} (${typeof data.svalue})`);\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error(`Error getting latest sensor data: ${error.message}`);\r\n      throw new Error(`Error getting latest sensor data: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  static async insertSensorData(sensorId, value, timestamp = null) {\r\n    try {\r\n      let query;\r\n      let values;\r\n      \r\n      // Ensure value is a number\r\n      const numericValue = parseFloat(value);\r\n      \r\n      if (isNaN(numericValue)) {\r\n        throw new Error(`Invalid sensor value: ${value}`);\r\n      }\r\n      \r\n      if (timestamp) {\r\n        query = `\r\n          INSERT INTO sensor_data (sensor_id, svalue, recorded_time)\r\n          VALUES ($1, $2, $3)\r\n          RETURNING *\r\n        `;\r\n        values = [sensorId, numericValue, timestamp];\r\n      } else {\r\n        query = `\r\n          INSERT INTO sensor_data (sensor_id, svalue)\r\n          VALUES ($1, $2)\r\n          RETURNING *\r\n        `;\r\n        values = [sensorId, numericValue];\r\n      }\r\n      \r\n      console.log(`Inserting sensor data: sensorId=${sensorId}, value=${numericValue}`);\r\n      const result = await db.query(query, values);\r\n      console.log(`Sensor data inserted successfully:`, result.rows[0]);\r\n      \r\n      // Không cần kiểm tra ngưỡng ở đây nữa vì database trigger sẽ tự động làm\r\n      \r\n      return result.rows[0];\r\n      console.log(`Đã chèn dữ liệu cảm biến mới: sensorId=${sensorId}, value=${numericValue}`);\r\n    \r\n      // Kích hoạt kiểm tra cảnh báo ngay lập tức\r\n      const alertMonitorService = require('../services/alertMonitorService');\r\n      setTimeout(async () => {\r\n        try {\r\n          console.log(`Đang kiểm tra cảnh báo cho dữ liệu mới của cảm biến ${sensorId}...`);\r\n          await alertMonitorService.checkThresholds();\r\n          console.log(`Kiểm tra cảnh báo hoàn tất cho dữ liệu mới`);\r\n        } catch (err) {\r\n          console.error(`Lỗi kiểm tra cảnh báo: ${err.message}`);\r\n        }\r\n      }, 500); // Chờ 0.5 giây để dữ liệu được lưu hoàn tất\r\n      \r\n      return result.rows[0];\r\n    } catch (error) {\r\n      console.error(`Error inserting sensor data: ${error.message}`);\r\n      throw new Error(`Error inserting sensor data: ${error.message}`);\r\n    }\r\n  }\r\n  \r\n  // Method to check if sensor value exceeds thresholds\r\n  static async checkSensorThresholds(sensorId, value) {\r\n    try {\r\n      console.log(`Checking if sensor ${sensorId} value ${value} exceeds thresholds`);\r\n      \r\n      // Get sensor type\r\n      const sensor = await this.getSensorById(sensorId);\r\n      if (!sensor) {\r\n        throw new Error(`Sensor with ID ${sensorId} not found`);\r\n      }\r\n      \r\n      // Get alert configurations for this sensor type\r\n      const query = `\r\n        SELECT config_id, user_id, sensor_type, min_value, max_value\r\n        FROM alert_config\r\n        WHERE is_active = true AND LOWER(sensor_type) = LOWER($1)\r\n      `;\r\n      \r\n      const result = await db.query(query, [sensor.sensor_type]);\r\n      const configs = result.rows;\r\n      \r\n      console.log(`Found ${configs.length} alert configurations for sensor type ${sensor.sensor_type}`);\r\n      \r\n      const thresholdExceeded = {\r\n        isExceeded: false,\r\n        threshold: null,\r\n        type: null, // 'high' or 'low'\r\n        config: null\r\n      };\r\n      \r\n      // Check each configuration\r\n      for (const config of configs) {\r\n        console.log(`Checking config min_value=${config.min_value}, max_value=${config.max_value}`);\r\n        \r\n        if (value < config.min_value) {\r\n          console.log(`Low threshold exceeded: ${value} < ${config.min_value}`);\r\n          thresholdExceeded.isExceeded = true;\r\n          thresholdExceeded.threshold = config.min_value;\r\n          thresholdExceeded.type = 'low';\r\n          thresholdExceeded.config = config;\r\n          break;\r\n        } else if (value > config.max_value) {\r\n          console.log(`High threshold exceeded: ${value} > ${config.max_value}`);\r\n          thresholdExceeded.isExceeded = true;\r\n          thresholdExceeded.threshold = config.max_value;\r\n          thresholdExceeded.type = 'high';\r\n          thresholdExceeded.config = config;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      return thresholdExceeded;\r\n    } catch (error) {\r\n      console.error(`Error checking sensor thresholds: ${error.message}`);\r\n      throw new Error(`Error checking sensor thresholds: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = SensorModel;"
        }
    ]
}